{{- if and .Values.airflow.enabled .Values.airflow.jobRunner.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "starlake.fullname" . }}-starlake-wrapper
  labels:
    {{- include "starlake.componentLabels" (dict "component" "airflow" "context" .) | nindent 4 }}
data:
  # Wrapper script that executes starlake commands as Kubernetes Jobs
  # Usage: starlake-k8s <command> [args...]
  # Example: starlake-k8s load --domains=customer --tables=orders
  starlake-k8s.sh: |
    #!/bin/bash
    set -e

    # Configuration from environment
    JOB_TEMPLATE="/etc/starlake/job-template.yaml"
    NAMESPACE="${STARLAKE_NAMESPACE:-{{ .Release.Namespace }}}"

    # Configure kubectl for in-cluster authentication
    # Use kubernetes.default.svc as fallback when env vars not available (e.g., in Airflow subprocess)
    if [ -n "$KUBERNETES_SERVICE_HOST" ]; then
      KUBE_API_SERVER="https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}"
    else
      KUBE_API_SERVER="https://kubernetes.default.svc:443"
    fi
    KUBE_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
    KUBE_CA_CERT="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"

    # Set kubectl alias with in-cluster config
    kubectl() {
      /shared-tools/bin/kubectl --server="$KUBE_API_SERVER" --token="$KUBE_TOKEN" --certificate-authority="$KUBE_CA_CERT" "$@"
    }

    # Generate unique job name based on command and timestamp
    TIMESTAMP=$(date +%Y%m%d-%H%M%S)
    RANDOM_SUFFIX=$(printf '%04x' $RANDOM)
    COMMAND="${1:-unknown}"
    JOB_NAME="sl-${COMMAND}-${TIMESTAMP}-${RANDOM_SUFFIX}"
    # Kubernetes job names must be lowercase and max 63 chars
    JOB_NAME=$(echo "$JOB_NAME" | tr '[:upper:]' '[:lower:]' | cut -c1-63)

    # Build args array for YAML (JSON array format)
    # Proper JSON escaping to prevent command injection
    ARGS_JSON="["
    FIRST=true
    for arg in "$@"; do
      if [ "$FIRST" = true ]; then
        FIRST=false
      else
        ARGS_JSON="${ARGS_JSON}, "
      fi
      # Properly escape for JSON: backslashes first, then quotes, tabs, newlines
      ESCAPED_ARG=$(printf '%s' "$arg" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g' | tr '\n' ' ')
      ARGS_JSON="${ARGS_JSON}\"${ESCAPED_ARG}\""
    done
    ARGS_JSON="${ARGS_JSON}]"

    # Create temporary job manifest
    TEMP_JOB=$(mktemp /tmp/starlake-job-XXXXXX.yaml)
    trap "rm -f $TEMP_JOB" EXIT

    # Build env vars YAML (12 spaces indent to match template)
    ENV_FILE=$(mktemp /tmp/starlake-env-XXXXXX.yaml)
    trap "rm -f $TEMP_JOB $ENV_FILE" EXIT

    for var in $(env | grep -E "^SL_" | grep -v "^SL_ROOT=" | cut -d= -f1); do
      value="${!var}"
      # Escape for YAML string: backslashes first, then double quotes
      escaped_value=$(printf '%s' "$value" | sed 's/\\/\\\\/g; s/"/\\"/g')
      # 12 spaces for - name:, 14 spaces for value: (matching template)
      echo "            - name: ${var}" >> "$ENV_FILE"
      echo "              value: \"${escaped_value}\"" >> "$ENV_FILE"
    done

    # Read template and create job manifest
    # First pass: replace simple placeholders
    sed -e "s|__JOB_NAME__|${JOB_NAME}|g" \
        -e "s|__STARLAKE_ARGS__|${ARGS_JSON}|g" \
        -e "s|__SL_ROOT__|${SL_ROOT:-/projects}|g" \
        "$JOB_TEMPLATE" > "$TEMP_JOB"

    # Second pass: replace __ENV_VARS__ with actual env vars from file
    if [ -s "$ENV_FILE" ]; then
      # Use awk to replace __ENV_VARS__ with file contents
      awk -v envfile="$ENV_FILE" '
        /__ENV_VARS__/ {
          while ((getline line < envfile) > 0) print line
          close(envfile)
          next
        }
        {print}
      ' "$TEMP_JOB" > "${TEMP_JOB}.tmp" && mv "${TEMP_JOB}.tmp" "$TEMP_JOB"
    else
      # No env vars, just remove the placeholder
      sed -i '/__ENV_VARS__/d' "$TEMP_JOB"
    fi

    echo "=== Creating Kubernetes Job: ${JOB_NAME} ==="
    echo "Command: starlake $@"
    echo "Namespace: ${NAMESPACE}"
    echo "SL_ROOT: ${SL_ROOT:-/projects}"

    # Create the job (--validate=false to avoid openapi download issues)
    kubectl apply -f "$TEMP_JOB" -n "$NAMESPACE" --validate=false

    # Wait for pod to be created and get its name
    echo "=== Waiting for pod to start ==="
    POD_NAME=""
    for i in $(seq 1 60); do
      POD_NAME=$(kubectl get pods -n "$NAMESPACE" -l "job-name=${JOB_NAME}" -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
      if [ -n "$POD_NAME" ]; then
        POD_STATUS=$(kubectl get pod "$POD_NAME" -n "$NAMESPACE" -o jsonpath='{.status.phase}' 2>/dev/null || echo "Pending")
        if [ "$POD_STATUS" != "Pending" ]; then
          break
        fi
      fi
      sleep 2
    done

    if [ -z "$POD_NAME" ]; then
      echo "ERROR: Pod not created after 120 seconds"
      kubectl get jobs -n "$NAMESPACE" -l "job-name=${JOB_NAME}" -o yaml
      exit 1
    fi

    echo "=== Pod ${POD_NAME} started, streaming logs ==="

    # Stream logs (follow until completion)
    kubectl logs -f "$POD_NAME" -n "$NAMESPACE" -c starlake 2>/dev/null || true

    # Wait for job to complete and get exit status
    echo "=== Waiting for job completion ==="
    kubectl wait --for=condition=complete --timeout=3600s "job/${JOB_NAME}" -n "$NAMESPACE" 2>/dev/null && {
      echo "=== Job completed successfully ==="
      exit 0
    }

    # Check if job failed
    kubectl wait --for=condition=failed --timeout=10s "job/${JOB_NAME}" -n "$NAMESPACE" 2>/dev/null && {
      echo "=== Job failed ==="
      # Get exit code from pod
      EXIT_CODE=$(kubectl get pod "$POD_NAME" -n "$NAMESPACE" -o jsonpath='{.status.containerStatuses[0].state.terminated.exitCode}' 2>/dev/null || echo "1")
      exit "${EXIT_CODE:-1}"
    }

    # Fallback - job might still be running or in unknown state
    JOB_STATUS=$(kubectl get job "${JOB_NAME}" -n "$NAMESPACE" -o jsonpath='{.status.conditions[*].type}' 2>/dev/null || echo "Unknown")
    echo "=== Job status: ${JOB_STATUS} ==="

    # Return appropriate exit code
    if echo "$JOB_STATUS" | grep -q "Complete"; then
      exit 0
    else
      exit 1
    fi
{{- end }}
